# 20250626 总结

## T1([a](https://uoj.ac/problem/497)) [观察力] [区间 Dp]

应得:100 实得:100 难度:2 用时:2.5h

将每个元素变为相邻两个元素的 $\max$ 或 $\gcd$ 的技巧如 P12430. 不过在本题好像没什么用?

对于一类枚举断点转移的区间 Dp, 一种优化的思路是通过手玩样例观察断点是否只有较少的可能性 (比如要么是最左侧要么是最右侧). 最好能够证明.

## T2([b](https://loj.ac/p/523)) [观察力] [分类讨论]

应得:100 实得:0 难度:3 用时:0.5h

下班了, 就没写代码. 但难点主要在于实现.

对于一类匹配问题, 若一边的点度数较少 (如只有 2), 则可以将这一边的点换成更加简洁的结构 (如连接两个另一边的点的边), 使得问题转化为更简单的形式 (如给每条边定向使得每个点入度至多为 1).

给一棵树定向使得每个点入度至多为 1, 可以考虑枚举没有入度的点, 则其它的边是以这个点为根的外向树, 可以用数据结构简单维护每个点为根的答案. 而不应当使用 Dp 求最优的方案.

## T3([c](https://qoj.ac/problem/6197)) [字符串同构] [字典树]

应得:9 实得:0 难度:5 用时:0.5h

下班了, 就没写代码.

对于一类在可以对字符进行置换意义下判定两字符串等价的问题, 考虑将字符串做如下变换: 将每种字符第一次出现的位置写上 0, 否则将这个位置写上这个位置到上一个相同字符的位置之间出现的字符种类数. 则生成的值域在 $[0, |\Sigma|]$ 内的序列相等是两字符串等价的充要条件. 同时, 任何一个 0 的数量 (记作 $c$) 不超过 $|\Sigma|$ 的序列都对应了至少一个字符串, 且对应的字符串的数量为 $|\Sigma|^{\underline c}$.

对于一类计数能由 $s_1, \cdots, s_n$ 的各自一个子串拼接而成的字符串数量的问题, 考虑贪心地尽量在前面的字符串匹配完, 则对每个串建立 SAM 后容易 Dp.

## 结算

由于不可抗力导致真实考试时长只有 <3.5h.

T1 不经思考地写了 $O(n \log^2 V)$ 做法, 但事实上 $O(n \log V)$ 做法在此之后是不难想到的. 而前者写完后经典被卡常, 好在花了 0.5h 的时间拼了一个错误的剪枝就过了.
