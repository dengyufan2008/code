# 20250422 总结

## T1([a](https://www.luogu.com.cn/problem/P3543)) [差分] [闵可夫斯基和]

应得:68 实得:90 难度:3.5 用时:3h

乱搞多骗了一点分.

对于一类区间加减的操作, 理应先做一步差分, 从而变为单点加. 细节上可以考虑加入值为 0 的第 $n+1$ 个数, 这样即使是后缀加也对应了两个位置的修改.

对于一类 min + 卷积, 考虑每个函数是否具有凸性, 即使不能用简洁的式子表示出来.

## T2([b](https://vjudge.net/problem/EOlymp-10444)) [构造]

应得:15 实得:15 难度:4 用时:0.5h

最少颜色数使得有边的两点颜色不同 = 最大团大小.

网格图上的曼哈顿距离不超过 $d$ 的最大团就是旋转 45 度后边长为 $\frac{d}{\sqrt 2}$ 的正方形能框住的最多格点.

## T3([c](https://codeforces.com/gym/102586/problem/A)) [观察力] [势能分析]

应得:55 实得:55 难度:4 用时:1.5h

对于一类每次往 $S$ 加入一个数, 再删去最大值或最小值, 维护 $S$ 做完 $m$ 次操作后的形态的问题, 可以支持 $O(m)$ 地往 $S$ 中插入一个元素. 具体的, 只需维护每个操作删去的数即可, 每次加入元素就从头到尾扫一遍.

对于一类维护进行 $m$ 次操作后的结果的问题, 若不关心中间的结果, 则可以考虑调换某些操作之间的顺序使得结果不变, 即使中间的结果可能改变, 从而只关心每组操作的集合, 以降低一组操作的修改量. 比如对于 $m$ 次操作, 将当前变量 $x$ 与 $a_j$ 比较, 若 $x < a_j$ 则交换 $x$ 和 $a_j$, 则可以将 $a_j$ 合并为一个集合, 每次加入 $x$ 并弹出集合内最大值.

## 结算

T1 第一步的差分就没想到, 但居然会了一个与正解毫无关系的 $O(n^2)$ 做法. 但在设计 Dp 状态时没有想清楚下标范围, 导致使用了 ``unordered_map``, 乱搞跑不过去, 最终重构了代码才跑过去.
