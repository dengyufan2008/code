# 20241224 总结

## T1(a) [二进制分组] [元素重编号]

期望:100 实际:100 难度:2.5 用时:1h

判断两个二进制编号是否相等时, 需要分类讨论左 0 右 1 和左 1 右 0 的情况, 则会带有两倍常数. 事实上选取一个稍大于 $\lceil \log_2 n \rceil$ 的数, 并只使用 popcount 相等的那些数来重编号, 即可保证一定存在一对左 0 右 1.

交互题中若需要引用特殊头文件, 不应使用尖括号而应当使用引号.

与这道 [题](https://www.luogu.com.cn/problem/P11344) 用了相似的思路.

## T2(b) [观察力] [BDFS 序] [树链剖分] [线段树二分]

期望:40 实际:10 难度:3.5 用时:**1.5h+1.5h**

下考后 1min 写完代码 (11k) 且过了 40pts, 难绷. 神奇的是我 1.5h 赶出来的巨长代码居然没挂.

数据结构题中求解原问题时, 若原问题为最优化问题, 一个重要思路为考虑原问题的答案最劣可能是多少, 若取值范围极小则直接分类讨论. 注意不遗漏特殊情况, 以答案为拓扑序从优到劣考虑.

使用树链剖分+线段树判断一条链是否是前缀 $<x$ 后缀 $>x$ ($x$ 为给定整数) 的方式为, 查出每个重链的 $\max$ 与 $\min$, 找到分界点唯一可能在的位置 (多个和没有的情况是简单的) 并在对应线段树上二分.

同 20240514 T1. 事实上对于一类与链, 子树, 较小的邻域有关的操作, 另一种维护方式 (还没有实现过) 为, 对每个结点 $x$ 维护 $t_i$ 表示 $x$ 的非重儿子的所有子树内的第 $i$ 层结点的值都需要加上 $t_i$, 各种操作都是可以做的. 但是似乎会复杂很多.

## T3(c) [01 trie] [计数 Dp]

期望:5 实际:5 难度:4 用时:0.5h

对于一类填表格使每一行组成的字符串递增的限制, 考虑使用 Trie 树, 则按先列再行的顺序进行决策时只需考虑一个结点应当连哪些出边. 尤其在字符集大小为 2 时.

对于一类对 每个阶段的发生变化的编号最小的元素 的限制, 无需将阶段中每个元素的以前状态记录下来, 而可以在状态中钦定当前阶段无需考虑这一限制, 分类讨论编号最小的元素如何合法地转移, 并枚举第一次发生变化的阶段即可.

优化状态时应当考虑哪些量是最终统计答案所必需的, 其余的尽可能的合并.

## 结算

在研究 ``#include`` 上花费了 20min, 求解 T2 的原问题花费了 1h. 减少这两部分用时应当能够在下考前写完 T2.
