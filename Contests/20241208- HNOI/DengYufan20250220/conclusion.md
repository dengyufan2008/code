# 20250220 总结

## T1(a) [观察力] [前驱树] [倍增]

期望:100 实际:100 难度:1.5 用时:1.5h

对于一个序列, 若将 $i$ 与 $i$ 的前驱看作一个区间, 则区间不会严格包含与严格相交 (指端点需要互不相同), 证明考虑分类讨论两个数的大小关系. 若将 $i$ 向 $i$ 的前驱连边, 则会得到一棵树, 且每一条链都是单调的. 在一些不断跳跃前驱的题目中可以用到. 同理有 Border 树.

随机排列中前驱树的深度是 $O(\log n)$ 的. 对于一类数据随机多次询问的题目, 考虑将一次询问涉及到的元素从 $n$ 粗略的过滤到一个更小的值 (如前驱树的深度), 然后写程序验证其的量级.

对于归并排序 (以升序为例) 两个有序序列的操作, 查询第 $i$ 次移动指针后两个指针分别的位置可以做到 $O(\log n)$. 具体地, 二分或倍增下标 $x$, 需保证 $2x \le i$, 判断考虑 $a_x$ 与 $b_x$ 的大小关系, 若 $a_x < b_x$, 则 $a_x$ 在归并后的排名 $< 2x \le i$, 故可以删去 $a_i$ 的前 $x-1$ 项, 反之同理. 二分复杂度为 $O(\log_2 n)$, 倍增复杂度为 $O(\log_{\frac{4}{3}} n)$.

## T2(b) [SAM] [树形背包] [重链剖分] [DDp]

期望:40 实际:40 难度:3.5 用时:1.5h

同 20241208 T2 string. 正解实现难度极高, 故考场上没有写.

对于一类选取 $S$ 的若干子串, 满足 LCS 的某些限制的题目, 考虑使用 SAM.

将 $S$ 的 SAM 建立后, $S$ 的一个前缀对应的 SAM, 一定是这个 SAM 的某棵虚树. 或言之, 前缀往后移动只会在当前 SAM 的一条边中插点, 或插一个叶子. 故重链剖分维护 DDp 是容易的.

## T3(c) [贡献差分] [自动机展开] [格路计数]

期望:30 实际:30 难度:4 用时:1h

对于一类计数题中带权的贡献, (如选取到排列中的 $i$ 贡献为 $w_i$, 整个贡献为选取到的所有数的贡献之和), 若权值的值域较小, 则可以枚举权值, 计算贡献至少为这个值的方案数, (如计算每种方案选取到 $w_i \ge t$ 的数量之和).

对于一类 $\forall 1 \le i \le n, ans \leftarrow ans + a_i, ans \leftarrow \min(ans, b_i)$ 的自动机形式, 若 $a_i \ge 0$,  $b_i$ 单调不降, 则有 $ans = \min_{i=0}^n \{ b_i + \sum_{j=i+1}^n a_j \}$. 证明考虑 $ans$ 最后一次被取 $\min$ 的位置, 这个式子在这个位置取到最小值.

对于一类 01 序列计数问题, 考虑将前缀的 0 的个数, 1 的个数作为坐标, 将限制条件放在坐标系上, 转化为格路计数问题.

## 结算

T3 使用的 $O(n^3+qn)$ 做法完全没有用到贡献差分的技巧, 而是直接统计了每个数被选中的方案数, 并在这一思路上一直思考到下考. 事实上略加思考可以发现, 若正解是这样的思路, 则 $a_i$ 的单点修改毫无意义, 且无需保证 $a_i \le 10^6$. 不过能拿到的部分分都拿到了.
