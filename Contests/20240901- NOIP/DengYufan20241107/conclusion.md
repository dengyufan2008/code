# 20241107 总结

## T1(cloud) [差分] [集合 Dp]

期望:100 实际:100 难度:1 用时:0.5h

对于一类区间加 $x$ 的操作, 考虑将原序列和目标序列均进行差分.

对于一类集合 Dp, 若转移是枚举一个不在 $S$ 里的元素并加入, 则比起直接枚举 $[1, n]$, 考虑 ``s ^ (1 << n) - 1`` 不断删去 ``lowbit`` 可以获得更小的常数.

## T2(sing) [构造] [贪心]

期望:100 实际:100 难度:3 用时:1.5h

对于一类需要一些区间出现的数等于全集的限制, 考虑从左往右依次构造并时刻满足右侧全集的数恰好都出现过一次, 然后贪心地将当前数放在最靠左的合法后继.

感觉缺乏泛用性, 甚至这个做法都是手玩后直接想到的.

## T3([basketball](https://www.luogu.com.cn/problem/P10041)) [区间 Dp] [钦定状态]

期望:over 68 实际:12 难度:4 用时:**2h**

若区间 Dp 的转移中子区间需要满足某些限制 (如转移途中不能和 $l-1$ 或 $r+1$ 发生合并), 则考虑直接给状态钦定上这个条件并修改转移.

对于一类最优化区间 Dp, 若转移的形式为选择一个特殊的子序列, 贡献为子序列剖出的若干区间的 $f_{l, r}$ 值之和, 则事实上只需要考虑子序列包含了 $l$ 和 $r$ 的情况, 其余情况可以由两个区间拼起来转移. 且此时无需在内部 Dp 子序列 (这样做是 $O(n^4)$ 的), 可以额外设状态 $g_{l, r}$ 表示已经选了一个包含 $l$ 与 $r$ 子序列, $f$ 与 $g$ 互相转移是容易的, 则做到了 $O(n^3)$.

## T4(calm) [树形 Dp] [二分答案] [邻域] [线段树合并]

期望:24 实际:8 难度:4 用时:0.5h

看错题了, B 走的最后一条路径同样要求未走过, 导致链的部分分式子推错.

经典套路, 但改题的时候还是没想出来. 对于一类转移只含 max 与 min 的 Dp, 若最终只关心一个位置的值, 则可以二分这个位置的值, 从而将值域变为只有 0 1 或只有 -1 0 1. 如 20241010 T4 median.

对于一类与邻域有关的最优化树形 Dp, 若转移为差分约束的形式, 考虑以值域为拓扑序 (特别地, 当可能的取值只有两种时可以依旧使用树形拓扑序, 并只用更优的值尝试更新), 每次将邻域内的点赋值并删去, 则可以在 lca 处将一个点的值转移到另一个点上. 以深度为关键字, 用可并小根堆解决; 也可以直接按 dfn 建线段树, 每次查找子树内深度最浅的没被删的点. 显然后者更优.

可并堆可以用线段树合并实现, 时间复杂度一致但常数稍大, 空间复杂度多 $\log$, 但泛用性更高. ~~而且我不会可并堆.~~

## 结算

考场上想到了 T3 的 $O(n^4k^2)$ 做法, 但自信实现了一个经过错误优化的 $O(n^3k^2)$ 做法后发现假了, 便理所当然的认为 $O(n^4k^2)$ 做法也是假的, 便神秘的在最后的 30min 不写 $O(n^4k^2)$ 做法而是试图给 $O(n^3k^2)$ 做法加补丁. 脑子坏掉了.
