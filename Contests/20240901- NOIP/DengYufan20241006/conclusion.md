# 20241006 总结

## T1(string) [无]

期望:100 实际:100 难度:1 用时:0.5h

略.

## T2(forward) [容斥] [矩阵乘法]

期望:50 实际:50 难度:2 用时:**2h**

显然的矩阵乘法优化转移 Dp, 且列出了初步的 Dp 方程, 但由于直接思考了转移矩阵的形态并没有去优化这个方程. 别跳步骤或是想当然.

矩阵乘法优化 Dp 的基础始终是 Dp 方程, 图论中邻接矩阵的若干次方只是初始向量为全 1 的特例.

矩阵乘法卡常技巧: 当矩阵尺寸较大时, 将靠后的矩阵转置再枚举可以使内存访问连续; 使用 ``unsigned long long`` 并循环展开 16 项可以大幅减少取模次数.

## T3(grouping) [并查集] [Dp]

期望:50 实际:35 难度:3 用时:1h

全是环的情况没有写完, 且最初的想法有部分错误.

若当 ``check`` 成功后可以得知某些操作是最优/必需的从而直接执行, 则不妨考虑失败后是否也可以得知某些操作是最优/必需的, 从而利用势能分析来减少 ``check`` 的次数. 换言之, 将已考虑完的情况作为条件一同进行推论.

对于一类背包 Dp, 若只查询最终某种价值能否被组成, 且需要支持动态地插入删除, 则可以将 0/1 Dp 改为方案数 Dp, 并选取一个大质数 $P$ ($10^{17}$ 级别) 作为模数, 设方案数上界为 $V$, 查询次数为 $q$, 则错误概率为 $\frac{q \log_{P} V \ln P}{P}$.

## T4(path) [分类讨论] [观察力]

期望:50 实际:50 难度:3 用时:0.5h

树上一点到固定两点的距离的最小值, 其取两侧的分界线恰为这两点链的中点. 更广泛地说, 引入更多元素 (一点到固定两点路径的交点) 来得到新元素的性质从而反向限制原元素.

对于形如是否存在一点满足条件的查询, 考虑将该点需满足的条件变形 (此前或许需要缩小该点的选取范围, 如树上所有点 -> 直径) 使得分别与该点和查询的点相关, 从而可以离线处理.

## 结算

打的稀烂. 感觉智力回到了两年前, 基础过差导致的.

每道题的思考都停留在了较浅层面, 事实上有 10-20 pts 都是在经过稍进一步思考后容易拿到的.

较简单的题目, 得到中等分后需要回退思路的可能性会极低, 一般可以继续往下想.
