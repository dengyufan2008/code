# 20241031 总结

## T1(maze) [计数 Dp] [提前去除非法贡献]

期望:100 实际:100 难度:1.5 用时:1h

尽管有时统计区间内元素的计数 Dp 无需差分, 但差分总是没有坏处的.

对于一类需要保证合法的计数 Dp, 若某个状态非法后无论如何转移都非法, 则可以在最前面的非法位置减去这个状态的贡献, 之后正常转移.

## T2(cablecar) [单调队列]

期望:100 实际:100 难度:1 用时:1h

当数据范围达到 $2 \times 10^6$ 级别时, 尽量将 $\log$ 去掉, 否则容易 TLE. 且此时使用 ST 表对空间的负荷很大, 需要注意空间问题. 险些挂到 40pts.

对于一类形如 相邻两个选择的点距离不能超过 $k$ 的限制, 在 Dp 时记下距离上一个选择的点的距离是愚蠢的, 应当直接从上一个选择的点转移过来.

## T3(apples) [贪心] [可重集 Dp]

期望:100 实际:100 难度:2.5 用时:1.5h

将集合 $S$ 中的数一一放到环上, 使得相邻两数之差的绝对值的最大值最小, 一种最优的方案为将 $S$ 排序后看作一个序列, 正序放奇数位的, 逆序放偶数位的. 证明考虑每个间隙对答案的贡献至少要带上旁边一个间隙.

一个可重集 $S$ 满足 $\sum_{i \in S} i = n$ 的子集个数是较少的, 当 $n = 150$ 时仅有 $4 \times 10^6$ 个.

当 Dp 的状态中带了一个可重集时, 一般的状压方式为将其压为一个混合进制数, 则每次枚举状态并展开再转移再压缩, 因为需要对变量取模而常数较大. 可以直接搜索这个可重集并维护每个元素的出现次数, 转移时直接加上对应的变化量即可.

## T4(run) [点分治] [去除非法贡献]

期望:44 实际:44 难度:3 用时:1h

感觉大多数基础点分治题, 难点都在于想到点分治, 后面都是板.

改题时递归到子树继续分治的部分将 ``s = v[i].s > v[x].s ? _s - v[x].s : v[i].s;`` 写为了 ``s = min(_s - v[x].s, v[i].s);``.

点分治并不局限于求解链相关的问题, 对于连通块相关的问题本质上可以认为一个点在连通块内当且仅当父链上的点都合法.

点分治求解计数类问题时, 由于统计的链的开头和结尾不能在同一颗子树, 可以多跑若干次相同的算法将这部分贡献减去.

## 结算

没有策略, 所以没有大的失误 (?). 每道题都做的很顺.

写代码的正确率低了, 调了很多地方, 尤其是 T4 的链的部分分下考前 3min 才调完, 导致少写一个预计实现时间 30min 的部分分.
