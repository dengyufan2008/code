# 20241015 (补 20241004) 总结

## T1(alive) [Meet-in-the-Middle]

期望:100 实际:100 难度:1 用时:0.5h

略.

## T2(aspect) [排列 Dp]

期望:100 实际:100 难度:1 用时:0.5h

略.

## T3(oneness) [观察力] [预处理答案]

期望:80 实际:100 难度:3 用时:**2.5h**

认为答案不超过 $O(\sqrt n)$, 但显然是错误的.

对于一类每次可以加 $[l, r]$ 内任意一个整数的背包, 加 $k$ 次后能够组出的值域为 $[kl, kr]$ 内的每一个整数. 则 $v$ 若满足 $\lceil \frac{v}{r} \rceil \le \lfloor \frac{v}{l} \rfloor$, 加的最小次数为 $\lceil \frac{v}{r} \rceil$; 否则无法组出.

对于 $n$ 个点组成的若干连通块, 考虑一个连通块内的复杂度上界能否从与 $n$ 有关变为与 $size$ 有关.

对于多次询问的问题, 若两个特定的询问间存在递推关系, 且询问总数可以接受, 则可以将预处理所有答案.

## T4(proud) [观察力] [调和级数] [并查集]

期望:64 实际:20 难度:3.5 用时:1h

$O(n^2)$ Dp 的初始值设置错误, $f_{i,i}$ 应为 $\min_{j=0}^{i-1} \{f_{i,j}+1\}$ 而非 $i+1$, 从而线段树优化 Dp 也是错误的. 对于有先后顺序的不同操作应当分步转移, 如添加当前位的字符和复制当前前缀.

当可以进行两种操作且第二种操作没有限制, 能进行第一种时进行第一种一定更优时, 可以贪心地进行操作.

对于一类复制整串并在后面某个位置粘贴的操作, 前缀 $i$ 粘贴的次数至多为 $O(\frac{n}{i})$ 次, 则可以调和级数.

当前缀的长度一定时, 判断某个区间是否等于这个前缀, 应当使用 $\text{len}$ 数组在区间头判断而非 $\text{nt}$ 数组在区间尾判断.

只会合并 $i$ 与 $i+1$ 的并查集时间复杂度为均摊 $O(1)$ 的. 证明考虑设势能为每棵树的最大深度之和 (此时树的形态是一条链挂一堆点).

## 结算

T3 思考根号分治花费了 1h, 而没有尝试确定一个更紧的复杂度上界.

明智的一点是在 T3 的最后 20pts 还不会时先去将 T4 的部分分写了. 事实上到下考也不会 T3 的正解.
