# 20240506 总结

## T1(soulist) [期望] [离散化]

期望:24 实际:16 难度:3.5 用时:2.5h

**我是傻逼.**

- `cout << Ask(l, r) << '\n'` 应为 
  
  `cout << Ask(l, r) % kMod << '\n'`.

- `if (n <= 19 && m <= 19 && 0) {` 应为
  `if (n <= 19 && m <= 19) {` .

对于一类修改与查询都只与相对大小关系有关的期望问题, 考虑维护 $P(a_i < a_j)$. 事实上是一种另类的离散化, 因此时间复杂度不应与 $n$ 有关.

## T2(whiteqwq) [Ex GCD] [Ex CRT] [不会]

期望:12 实际:8 难度:5 用时:1.5h

没有写完, 但神秘地得了 8pts. 事实上, 输出 $n$ 有 20pts.

一类字符串匹配算法无需一定是相同匹配. 以 Manacher 为例, 只需满足回文内部一边有回文另一边对应位置也必然回文即可. Ex KMP 则只需满足等号有传递性即可. 事实上后者用的不多.

## T3(beautiful) [观察力] [分块打表] [Min_25 筛]

期望:60 实际:60 难度:2 用时:1h

求解一个前缀有多少质数可用 Min_25 筛.

打表时为缩短代码长度有如下技巧:

- 打表的内容尽量与要求的东西相接近以减少信息量.
  
  例如, 要求前缀质数个数则打表区间质数个数比打表质数优.

- 分块使得散块的规模可直接暴力做从而减少存的内容.

- 将十进制改为更大的进制.

- 若每个元素都等长, 将数组改为字符串可以省去逗号.

- 代码长度通常为 100k.

## 结算

想 T1 的时间过于长了. 事实上这题并不是我能够初见切的题.

需要正确估计写剩下的暴力所需时间, 并计算出什么时候应当结束想题开始写暴力.
