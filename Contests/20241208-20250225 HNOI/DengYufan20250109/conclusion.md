# 20250109 总结

## T1(a) [线段树] [树链剖分]

期望:100 实际:100 难度:2 用时:1.5h

若需要维护若干区间是否合法, 且合法条件所涉及到的元素集合 (例如单调递增涉及到的元素集合就是所有相邻元素的二元组) 较少, 则可以直接维护每个元素集合的合法性, 而无需对每个区间分别判断是否合法.

例如, 维护二叉树上每个子树是否是 BST, 与其使用线段树维护中序遍历中区间是否单调, 不如对于一对相邻的不单调的数, 将其的 LCA 到根的链全部设为不合法.

对于一类动态增删点, 维护所有点到根的路径的并的大小的题目, 显然可以树链剖分, 但更好的做法是维护 $\sum_{i=1}^k dep_{s_i} - \sum_{i=1}^{k-1} dep_{Lca(s_i, s_{i+1})}$, 其中 $s_i$ 为点集按 dfn 排序得到的序列.

当需要判断相等的字符串都等长时, 可以用 SAM 上对应的节点来代替哈希.

## T2(b) [状态压缩]

期望:75 实际:45 难度:3 用时:2h

对于一类需要动态维护逆序对个数的 Dp, 若决策的是每个位置选或不选 (或言之选取的是一个排列的子序列), 则无需维护前面的数的集合, 只需维护后面的数将值域分割成的每一段内选择的数的个数即可. 相比于前者 $O(2^n)$ 的状态, 后者的状态数是将 $n+1$ 划分成若干个数的和后这些数的乘积的最大值, 最劣情况下是 $O(3^{n/3})$$.

## T3(c) [分块] [SAM] [扫描线]

期望:30 实际:30 难度:4.5 用时:1h

对于一类区间询问这个区间内的前缀的贡献和的问题, 可以考虑分块, 将前缀分为跨过了区间内第一条分块线的和没跨过的来分开做.

## 结算

下考前 10min 意识到 T2 的随机数据可以给暴搜加上最优化剪枝, 但由于考场上运气过好, 造的唯一一组大样例跑的飞快便认为足以通过, 从而浪费了 5min 的继续卡常的机会.

测试运行时间时若程序使用了随机化或极度依赖数据, 应当多测试几组.
