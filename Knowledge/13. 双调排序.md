# 双调排序

考虑一次操作 ``CompareAndSwap(i, j)`` (后称 ``F(i, j)``) 为比较 $a_i$ 与 $a_j$ 的值, 若 $a_i < a_j$ 则交换 $a_i$ 与 $a_j$. 其中 $i \neq j$. 显然存在某些排序算法可以与具体序列无关地只使用这个操作来排序, 如选择排序和冒泡排序.

定义一次并行操作为若干操作集合 $S = \{(i_1, j_1), ..., (i_t, j_t)\}$, 且满足可重集 $T = \{x | (x, y) \in S \lor (y, x) \in S\}$ 中每个元素只出现一次. 即操作涉及到的元素彼此无交. 定义并行时间复杂度函数 $\Omega$ 为排序算法在尽可能的并行后所需的并行操作次数的数量级.

现介绍一种 $O(n \log^2 n)$, $\Omega(\log^2 n)$ 的排序算法.

---

定义一个序列为双调序列, 当且仅当存在一种该序列的轮换, 使得其为一个单峰序列. 考虑如何排序一个长度为 $2^n$ 的双调序列.

考虑将其拆成左右两半, 并一一对应地进行 $F(l, mid+1), F(l+1, mid+2), ... F(mid, r)$. 发现其左右两半分别变成了双调序列, 且左边的最大值小于等于右边的最小值.

<details><summary>Proof</summary>

> 容易发现只要证明对每个 01 序列合法即可. 对于 01 序列来说双调序列等价于连续段不超过三个.
> 
> 若其中一半连续段只有一个, 是平凡的. 一定会全部交换或全部不交换, 则交换前后两半的连续段都不超过三个.
> 
> 否则两边都恰有两个连续段, 则会交换一个前缀和一个后缀. 发现假设分别删去 1 的连续段后两半都只剩一个 0 的连续段, 则由于两半都只有两个连续段, 换过来后连续段数量至多增加 2.
</details>

故只需要操作后递归地排序即可. 发现同层的递归均可并行运算, 故 $O(n \log n)$, $\Omega(\log n)$.

考虑如何将一个长度为 $2^n$ 的一般序列转化为双调序列. 发现每一个数都是一个双调序列, 故可以将每一个小序列交错地升序和降序排序, 随后相邻的两个小序列就可以合并成一个大的双调序列. 发现同层的排序的同层的递归均可并行运算, $O(n \log^2 n)$, $\Omega(\log^2 n)$.

考虑其需要支持升序和降序排序, 难以将序列长度扩展到任意, 故考虑将如何降序排序删去. 若对每个小序列都升序排序, 则序号为偶数的小序列需要 reverse. 考虑排序这个合并后的大双调序列, 在第一次递归时把右侧的编号 reverse, 即进行 $F(l, r), F(l+1, r-1), ... F(mid, mid+1)$ 操作, 之后显然两半的序列又分别成为了双调序列, 故使用和之前一样的排序方式即可.

现在只需对序列进行升序排序, 故对于序列长度不是 $2^n$ 的, 考虑在其后补上若干 $+\infty$ 即可.

$O(n \log^2 n)$, $\Omega(\log^2 n)$.
