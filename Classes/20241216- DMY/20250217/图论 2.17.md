### CF 2046D

感觉非常像 flow，用流表示每个人的行动。每个点的入边至少是 1，然后出边是 ai，加上原来进来的那个人。从原点连过来的边第一个流量需要费用，后面不需要，求一个最小费用可行流。

编一下具体的细节：

1. 一个 SCC 会产生环流。所以需要提前把 SCC 缩一下。
2. 一个 SCC 里面可能没有人，不能从原点连边。
3. 最小费用流，拆流量不会优先走需要代价的边。解决方法建立新点，流量流向入需要需要费用，流向出不需要费用。或者也可以入向出连一条流量为 1，费用为 -1 的边，表示如果入边非零那么就能 -1。

### CF 2029I

最小方差，容易想到枚举方差是多少。

接下来你要增广 m 次，求一下最短的增广路径即可。这部分可以暴力 O(n)。总的时间复杂度 O((nm)^2)。

### CF 2041G

想法感觉比较直接，难点是找到一个，能写出来的做法。

直接离散化，缩图好像并不太简单，比如一个长条可能需要区分两端的点之类的。

一个参考的做法是首先把边框上全是黑格的行/列去掉，对整个外边界建一个点。然后两条线在不同列对角相邻就连边。这样白格不连通当且仅当黑格成环。然后比较好判了。

### CF 2041 K

最大反链不超过 16，表示整个图可以划分成不超过 16 条链。

对于每条链，可以通过 BFS 计算可达。难点在于如何划分，如果直接跑网络流相关的，需要的是 n - 16 次增广而不是 16 次。

事实上如果贪心的每次找到一条最长链去掉，那么会被划分成不超过 O(k log n) 条链。因为最大反链不超过 k，所以图里面的最长链一定超过 n/k，也就是最后的链不超过 log n / log (k/(k-1))。

似乎有一些乱搞或者是对的做法：比如随机选一个点，求出 in 和 out，如果 in 的大小小于 out，那么在 in 里面的点肯定不会是答案，可以全都删除。

类似的题目：https://qoj.ac/problem/8943

### CF 1815 F

比较困难的题。想法就是类似求染色，我们按某个顺序逐位确定这些点，我们要保证每个点不会和前面的矛盾。后面的不管。

可以通过枚举发现，三角形在固定前面两个数字之后，第三个数字仍然有机会取到比较多的值。并且第二个数也可以有多种取法。

- 1,4,4 gives weights 5,5,8
- 2,3,3 gives weights 5,5,6
- 3,2,2 gives weights 5,5,4
- 1,4,3 gives weights 5,4,7
- 2,3,2 gives weights 5,4,5
- 3,2,1 gives weights 5,4,3

然后注意到 |A+B| >= |A| + |B| - 1，每个点如果是第二个点，它会贡献一个邻居，并且一个多余的取值。如果是第三个点，它会贡献两个邻居，两个多余的取值，所以我们这个点一定有得选。

### CF 1835 F

首先这个就是 Hall 定理。Hall 定理的反例，只要增广爆了就能找到。

然后假设找到了一组完备匹配，刻画一下好的集合。因为存在一个完备匹配，那么好的集合也就是 S = {u1, u2, ..., uk} 然后 N(S) = {p[u1], p[u2], ..., p[uk]}。也就是一个点被选入之后，它在残量网络上可达的点也要被选入。

如果残量网络的可达性不变，那么这个好的关系也不会变。

对于一个 SCC，使用环可以构造。对于缩完之后的 DAG，找最小边使得可达关系不变，是个经典的贪心问题。

### arc176_e

数据范围比较的诈骗，实际上不太存在 O(2^n) 或者 O(n!) 枚举然后贪心之类的做法。

用切糕的方法建模，把 X Y 都拆一条链。每个操作建一个点，看这个点在 S 或者 T 中表示给 X 或者 Y 取 max，求最小割即可。

### arc153_f

显然大多数情况下，乱染色，是会出现三种颜色的路径的。刻画一下三种颜色都有，并且所有简单路径都不是三色的情况。

首先对于树的情况，容易发现一定有一个点边上有三种颜色。这个统计比较简单。

如果一个环染了多种颜色，能发现其实很难做到合法。可以通过手玩和猜结论得到差不多的结果。这边还是学一下题解的讨论方式。

如果有一个三色的简单环：

- 环长一定不超过 3。
- 挂出去的点颜色必须和对边相同，所以只能有一个点能挂出去，并且连出去的边颜色都会一样。

如果有一个双色的简单环，但没有三色环，通过一些讨论可以得到不合法。

每个环同色，那么就缩一下点双，变成树的情况。

### arc164_f

首先注意到每个点被翻转次数是固定的，也就是取了之后获得分数只和层数有关。

首先可以想到会抢 +1 的叶子，然后只剩一些 -1 的叶子。为了方便起见，我们称 -1 为坏点，1 为好点。目标选到尽量少的坏点。

现在只剩下一些坏叶子，如果是最后一个坏叶子，那么对手能选它的父亲，非常亏，并且不能交换先后手，也就是你要继续选坏点。所以你可以把它看成若干个单独的坏点，以及一个坏点和好点分成一组。

继续往上思考，对于一个坏点，有若干个好儿子，根据前面的分析，可以认为好儿子只有一个坏的儿子，并且是叶子。只有当没有可以选的时候才会去选这个分支，并且如果不把所有分支选完一定不会改变先后手。所以肯定会把所有的分支一起选完。

继续往上，对于一个好点，如果有若干个坏儿子，我们会按从小到大的顺序贪心地选这些坏儿子，把最大的分支放到最后取考虑。

也就是按奇偶分层跑 dp，坏点会把儿子的 dp 值都加起来。好点只保留最大的，把较小的单独当成一组。最后两个人会按照坏点个数从小到大选取这些组。

### QOJ 9276

首先如果一列只有一个数字，那么这个数字是固定的。可以把固定的数字做一个类似拓扑排序固定下来。如果已经有白卡的列，也不需要继续考虑。

现在每列至少有两个元素。根据题目描述，存在一个方案，使得至多一个白卡。如果找到这个方案，然后再全部取翻就能得到一组合法解。但是找到这个方案是 NP Complete 的。

但是因为解的存在性，所以每列任意保留两个还是有解的！然后就可以 2-SAT 了。

### QOJ 1197

非常困难的题。首先可以想到这是个网络流题。

首先可以先画黑条，再画白条，再画单点。并且一个点，同向只会被画一次。实际上主要确定每个点横向是不是被黑/白条画过，竖向是不是被黑白条画过，分别记作bh, wh, bv, wv。可以唯一确定整个的代价。由于问题比较复杂，所以用更加代数化的方法解决。即最小割可以被刻画成 a * x(u) + b * !x(u) + c * x(u) * !x(v)。

具体的，对于画条本身的代价为 a * bh(i, j) + b * bh(i, j) * !bh(i, j + 1)，四个方向都同理。这里保证单点不优，所以不需要考虑长度大于等于 2 的限制。

因为保证了最优解里面同向的只会被涂一次，所以不需要考虑画条导致某个位置被画了多次的情况。

对于单点涂黑，代价为 c * !bv(i, j) * !bh(i, j)，限制为 inf * (wh(i, j) + wv(i, j))，即不能涂过白色。

对于单点涂白，代价为 c * bh(i, j) * !wv(i, j) * !wh(i, j) + c * bv(i, j) * !wh(i, j) * !wv(i, j)。限制为 inf * bh(i, j) * bv(i, j)，即不能涂超过。

这里看起来有三元关系，但是最优解里面同向不会涂超过两次，所以 bh(i, j) 为真的时候，wh(i, j) 也为真一定不优，可以把上式简化成 c * bh(i, j) * !wv(i, j)，同理可以简化后面的，所有关系都是二元关系。

然后发现代数式里面有 x(u) * x(v) 这样的项，这个是无法用最小割表示出的。但是观察发现只要把 bv, wh 的定义取反，所有的限制都变成 x(u) * !x(v) 的项，可以直接最小割。

补充：在一般最小割问题中，展开后 x(u) * x(v) 项前面的系数是负的就可以最小割。

### abc393_g

大概就是对偶一下，变成了一个带参的费用流问题。

经过一通分析，这个最优解会在一些分母不超过某个值的分数上取到，然后对这些离散的分数三分一下，三分之后的解用 primal dual 构造。

### arc190_e

这显然是一个一般图匹配问题，所以直接跑 LP 可能会出 0.5。

根据一些 ~~观察思考~~ 猜结论对拍，连续的一段 0.5 需要向下取整，然后可以线段树维护 dp 了。

严谨的论证需要用到 Tutte-Berge formula，毛估估就是这一段分配的比较平均，没有单个数太小或者太大，但是解方程解出了小数，于是需要把这个 0.5 调整一下，根据不知道为啥，调整 0.5 就够了。
