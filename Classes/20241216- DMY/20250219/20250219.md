### [QOJ 9915](https://qoj.ac/contest/1885/problem/9915)

一看就只能 bitset，考虑如何 bitset。每个右端点，记录当前 l + r = x 的串是不是还是回文的，每次找到爆了的位置。

需要分块卡卡空间。

### [QOJ 9406](https://qoj.ac/contest/1803/problem/9406)

首先只需要考虑较小的大于最大的即可。不妨设 x >= y, z 并且 yz <= zy。枚举 x 和 x 的前缀 y 之后，是个二维数点问题。

### [ARC175 F](https://atcoder.jp/contests/arc175/tasks/arc175_f)



### [CF 1909G](https://codeforces.com/problemset/problem/1909/G)

考虑枚举 xy，然后查询后面一段的循环节，即 T = (x + y) + y ^ k + z。这个类似求阶可以直接做到 O(log n)，但是要 hash，所以很难卡过去。

但是有神秘限制是 y <= LCS(x + y, y ^ k)。然后你滑窗的时候，可以利用这个性质，查新的 LCS 即可。最后还需要离线统计一下答案。

std 的做法比较精妙：我们直接枚举 y 的长度 q。首先有 x + y 在 lcp 里面，并且如果 x + y 可行，s 和 t 的下一位相同，那么 往后挪一位也是可行的。所以如果可行的话，区间的右端点一定是 lcp 的位置。对称的可以的到左端点一定是 lcs 的位置，也就是只要判断一个是否可行。

### [LOJ 6070](https://loj.ac/p/6070)

把区间不同子串的板子，搬到搞到 PAM 上就行了。

### [CF 1738H](https://codeforces.com/contest/1738/problem/H)

贺上面的做法看起来不太能过。好像可以搞一个前端带删的 PAM，但感觉很容易写错。

有个比较暴力的做法是，每次删除开头最多删除一个回文串，即最长的。可以找到这个点，查询子树里面有没有出现过的，大概是个单点修改，区间最小值，以及需要一个倍增，倍增好像改成离线 dfs + 二分。

### [NOI 2023 字符串](https://qoj.ac/problem/6759)

大部分情况，直接比较对应的整个串就可以了，这个可以后缀排序之后二维数点。

回文串的时候会有反例，如果对着 l 直接做，那么可能需要一些 PAM 上的手法。但是枚举中间位置就是简明二维数点。

### [CF 2053G](https://codeforces.com/problemset/problem/2053/G)

感觉比较神秘。首先考虑如果分出来的没有公共循环节，如果没有的话，可以证明贪心匹配加反悔是可行的。

有的话解方程或者暴力即可。

时间复杂度为 O(m log m) 的。

### [QOJ 7742](https://qoj.ac/contest/1435/problem/7742)

没学会题解，摆烂了。

### [子串 Border 查询](https://codeforces.com/gym/100962/problem/D)

经典问题，但感觉应该也有人不会。复习一下后缀树做法。

等价于找到最小的 p (l < p <= r)，满足 lcp(l, p) >= r - p + 1。

即考虑 l 在后缀树上往上跳，等价于在子树里找到满足条件最小的 p，用用线段树合并之类的求出子树即可。但时间复杂度为 O(dep) 的。

考虑经典树链剖分，等价于要快速计算一条前缀的答案，并且只要在 O(链头子树大小) 复杂度完成就可以。然后离线从前往后插入每个挂的点。限制等价于 p + D[p] > r 并且 p > l 的最小值，在线段树上二分即可。

O(n log^2 n)。

### [CF 700E](https://codeforces.com/problemset/problem/700/E)

首先只有后缀树上的节点是关键的，状态数被缩为 O(n)，然后从上往下贪心即可，判断是简单的区间查询。

### [QOJ 9571](https://qoj.ac/contest/1828/problem/9571)

和上面一个题，反着的 border jump。

如果是回文串，至少可以做到一半，而不是回文串，因为第一步只能选不超过一半的，至多只有一半。所以操作的时候一旦变成回文串，就只会对回文串进行操作。

- 如果是回文串，只会变成去掉两端，或者最长回文前缀，这个可以在 PAM 树上简单解决。
- 否则第一个回文串一定是某个左端点的最长回文前缀，每次找到能拼上去的前面的反串，然后扩展即可，这部分时间复杂度为 O(log ^2 n) 的。

### [CF 1043G](https://codeforces.com/problemset/problem/1043/G)

板子检测题。

显然答案最多是 4，然后进行一个分类讨论。

- -1: 没有重复字母。

- 1: 循环串。
- 2: aba 或者 aab 以及对称。aab 可以用优秀的拆分或者 runs 预处理出每个点开始的最短平方串长度。aba 可以贺个区间 border 板子计算。
  - 因为只要判定，border 有神秘做法。暴力检验长度不超过 O(sqrt(n)) 的，否则最短的 border 与 l 后缀排序不超过 sqrt(n)。因为没有更小的 border，所以每次出现不重复。
- 3: 只有 baac，abac 以及对称。abac 中 a 显然只会选一个。
- 4: 剩下的。

### [CF 1817F](https://codeforces.com/problemset/problem/1817/F)

好像是基本子串结构板子题。考虑如果不会的话，也可以用一些标准的后缀树分析解决。

### [CF 917E](https://codeforces.com/problemset/problem/917/E)

答案等于到 LCA 直链上的结果 + 拐弯的部分。直链上的结果相对简单，可以用 AC 自动机解决。拐弯的结果需要算出两边的 border 然后拼起来。

- border 拼起来能对两边 border 都建立 kmp 失配树，然后做二维数点。也可以用 log 段等差数列的方法。
- 求最长的 border 可以对模板串建 SA，然后去二分最大的 LCP。然后再 SA 上往前二分，找到最近的 = 这一段 LCP 的后缀。
